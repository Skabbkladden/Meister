\section{Evaluating usefulness}\label{jiveEval}
%om testen
In order to evaluate both the usefulness of JIVE, and the changes that were implemented, an evaluation was performed with a small group of students, one by one.
During this test, the students were given a demonstration of the main features of JIVE, using implementations of the first, and the last exercise of the MMI-course as examples.
After getting familiar with JIVE, they were shown the modified version, focusing on the new and modified features that were implemented.
They were then asked questions about how easily they understood the diagrams, and how useful they found the changes to be.
As well as whether the performance trade-off was acceptable for occasional use, if they could see themselves using JIVE, and if so, in what situations.
~\\

Regarding performance, it has already been stated in \autoref{preMethods} that the tracing behavior of JIVE must affect the analyzed program negatively.
The specific penalty varies with the complexity of the program, and the level of detail that is being logged.
The performance of each example program, with both versions of JIVE, and with two different levels of detail in the filter for the modified version, for a total of six measurements, were tested separately from the user evaluation, but on the same computer.
With the default filters, the programs used in the test had an average startup time of INSERT TIME, and responded to user input with a delay of no more than one second.
With the modified filter mechanism, and filters adjusted to include information on relevant classes, the startup time increased to INSERT TIME2, while the user input delay ended up at RESPONSETIME HERE.
~\\

It should be noted that the example programs were both relatively simple, with few events following directly from a user interaction.
While the program starts responding in a reasonable time, it may take unreasonably long time to finish responding.
If for example data was to be fetched from some source, processed and then displayed to the user, it would be expected to take significantly more time to finish, than if it was to alter a line of text already on display.
~\\

%resultat
The students that participated in the evaluation were mostly in their third year, and had already finished the MMI-course the previous semester.
This meant that they were familiar with the example programs, and had some knowledge of the MVC-pattern, and how it behaves in Java-swing.
While this excluded the experiences of someone completely unfamiliar to these concepts, it did give the insight of relatively fresh experiences, as the participants remembered what they were finding hard to understand back then.
There was also one participant who was in his second year, and as such, would take the MMI-course during the next semester.
~\\

%nytte av diag
The evaluation resulted in mostly positive feedback, with every participant seeing some kind of use for a tool like JIVE.
Of those in their third year, only one participant did not consider the use of diagrams to understand code to be useful.
In his experience, he learned just as well from reading the code directly, and building his own mental model of the program structure, but as he preferred simple text editors to \gls{ide}s, he could be considered to be outside of the target demographic.
On the other hand, he did recognize the usefulness of JIVE as a tool to create documentation, and for presenting his own work to other participants in a project.
The rest of the participants shared the view that JIVE, or a similar tool, could have been very useful when trying to understand the connection between \gls{gui} elements, listeners, and the actions that are triggered by them.
A few specifically mentioned that they found that connection to be difficult to understand.
One of them also had experiences as a student assistant, and recognized JIVE as a tool that could give students a needed insight into what is going on in their programs.
~\\

The diagrams themselves were found to be both sufficiently detailed, and easy to understand, showing the available information in a simple and structured manner.
The tendency for the diagrams to grow large and unwieldy did become a problem, especially when running with the less restrictive filter, showing many of the swing-internals.
When hiding everything but user-created classes, the diagrams remained at an acceptable size, although the sequence diagram got quite long after a while.
~\\

%ytlese
As expected, the participants all agreed that the performance of JIVE was too poor for continuous use, but they still found it acceptable for the occasional use that getting familiar with an example, or documenting a project would require.
While a larger project could take several minutes to reach the initial stable state for a user to interact, one would only be interested in including the entire project when generating documentation for delivery.
By using the filter to ignore well known parts of the project, one could more easily show the interesting or complex parts, while saving time.
In either case, the performance was not found to be a reason to not use JIVE at all.
~\\

%nytte av endringer
The implemented changes were generally well-received, with the ability to view a subsection of the sequence diagram in the isolated view being the most preferred change.
The changes to the filtering mechanism were found to still be somewhat cumbersome due to the lack of an easy way of importing an existing filter.
The modified labeling of object instances provided a small, but useful addition to the visible information.
~\\

%problemer
While the feedback from the participants was generally positive, they still found some areas that they thought could be further improved with new or modified functionality.
The mentioned challenge with importing an existing filter, was among the suggested changes, as well as adding a suggestion-functionality, similar to the autocomplete feature found in many search providers, when writing filter additions manually.
Also related to the filter, was the risk of diagrams  becoming so large that they would be nearly impossible to navigate, especially for larger programs, or when letting more objects through the filter.
To help with this, there was a desire to have the line of objects at the top of the sequence diagram visible at all times, regardless of how far down in the diagram one is currently looking, which would make the larger diagrams easier to navigate.
Another suggestion was to make it possible to trigger the isolated view from the mentioned line of objects at the top of the sequence diagram, instead of having to find both the desired objects, and then scroll down to find the first event it is involved in.
~\\


some new suggestions: always show line of objects on top of seq diag, regardless of how far down one is scrolling, desire for vertical collapse
complaints about information overload, and inflated diagrams, especially with increased filtering details, some concern on how larger projects might behave
