\section{Enhancing JIVE}\label{enhJive}
%todo: referanser til artikler og ordliste, legg til figurer for Ã¥ forklare bedre

In this section I will first explain the various features of JIVE, before identifying any shortcomings, and finally suggest improvements.

\subsection{Features}\label{jiveFeatures}

As mentioned in the prestudy, JIVE installs as a plugin in the eclipse IDE, adding another perspective in the environment.
The default views shown in this perspective are the "object diagram" and "sequence diagram" views, making the diagrams generated during debugging JIVEs two most apparent features.
The diagrams are updated according to the current state of the debugged program, so that the backtracking functionality allows you to see the entire execution graphically step-by-step.
The other views provided by JIVE are as follows: "contour model", "sequence model", "execution trace" and "search".
~\\

The object diagram-view shows the current state of the program by using a contour-diagram.
Contour-diagrams are based on an old technique to  give semantics to Algol-like languages.
The basis has been extended to support modern concepts, such as object-oriented programming.
Objects are represented by a box, or contour.
Within the contour, the objects variables are shown, with name, type and value.
The contour also uses arrows to point at other contours that are related, e.g. an other object representing the value of a variable, or an enumerator.
Inheritance is shown by putting the contour of an object within the contour of the extended object. 
Object instances are kept separate from the contours representing inheritance, but will have relational links when necessary.
Method calls are also represented in the diagram, in their own contours, linked to the calling object.
JIVE offers to hide some of the information, such as inheritance or the composition of objects, in order to make the diagram smaller, and easier to read.
Something that can be especially useful when working with larger programs, with many objects and relations.
Visibility is aided by the use of colors to highlight specific elements of the diagram, such as variables bound to objects, and method-calls.
~\\

The sequence diagrams are fairly standard, with threads and objects represented by boxes on a row at the top, each with a vertical life-line.
The actual sequence is shown with a thicker lifeline, with arrows representing method-calls.
In order to differentiate the threads where the execution is happening, the sequences are colored with the same color as the thread- box the sequence originates from, regardless of witch objects and methods are involved.
Right-clicking on a lifeline offers the ability to collapse method-calls originating from that lifeline in order to hide unnecessary information.
Right-clicking also offers to set the execution-state via the jump-option, updating the contour-diagram and -model to show that state.
~\\

Both of the diagrams can be saved as a high-resolution image at any time, so that one can look at diagrams from earlier runs, instead of being forced to view them through JIVE.
This also helps to visualize any changes made to a program, and to see what the effects are on the program flow.
They also share the ability to zoom in and out, further helping with the handling of larger diagrams.
~\\

Closely related to the diagrams, is the ability to quickly jump backwards and forwards between execution states.
This is enabled by the trace-log, containing an entry for every single event that occurs during execution of a program.
Each event is assigned an identifying number, in ascending order, and information about thread, type, caller, target, and the location of the source-code is stored.
The log is used as the basis for the models that make up the diagrams, and can be saved as both XML- and CSV-files for later use.
As mentioned in the Prestudy, logging every event has a significant impact on run-time performance, limiting the size of the programs that can be used in a meaningful way.
On the other hand, it allows the almost instant jumping between recorded states, as opposed to techniques that save a snapshot at predefined intervals, requiring the program to be run from the snapshot-state to the desired one, even if it is just a single step backwards.
~\\

The model-views each display an alternate view of their respective diagrams.
They show the data-model representing the diagrams in a hierarchical structure, much like the organization of files and folders.
Right-clicking on an event in the sequence model allows you to set the execution state to that event, and have the diagrams updated accordingly.
Clicking on elements in the contour-model allows you to inspect the values of objects and their variables.
~\\

Finally, the trace-log enables the use of queries to search for specific events in the execution.
The queries are presented through a new tab in the eclipse search-window, easily accessible through the search-view, and comes with several pre-defined templates to simplify searching.
For example, searching for when a certain variable gets a certain value, only requires the user to specify the variable-name, its parent, and the value.
It is also possible to write custom queries, using the JIVE-Query-Language.
~\\

\subsection{Shortcomings of JIVE}\label{jiveShortcomings}

Even though JIVE offers several useful features, there is still room for improvements, both for general use, and more tailored towards development of graphical interfaces, as is the focus of the MMI-course.
~\\

The diagrams are possibly the most useful feature of JIVE, showing a lot of information in an understandable way, and offering some useful interaction.
But there is still room for improvement:
Inner types are displayed with their automatically generated, and fairly anonymous, name unless given a proper name in code.
By default, most of the classes defined by the JRE itself are ignored.
For the sequence-diagrams, it is naturally not important no show the internal behavior of every object, but they are also hidden in the contour-diagram.
Related to this, is the lack of visual connections between standard-objects, and for example instances of listeners added to them.
~\\

The sequence-diagrams can quickly become huge and hard to navigate, and the zooming function has very few levels outward, as well as leaving all text to small to read when zooming out.
Additionally there does not seem to be any way to vertically compact the sequence-diagrams, making them unnecessarily long in certain cases.
~\\

Another potential for improvement is the stepping through recorded states, which currently requires manual interaction for each step, making replays of an execution infeasible due to the massive number of events recorded even for simple programs.

Keywords:\\
inner types in the diagrams\\
ignoring objects defined in jre, and their inner types are not linked\\
only step-by-step iteration through the log, or jump to specific point\\
colorizing listeners and other mvc-related objects\\
too few zoom-levels - big diagrams are cumbersome to navigate\\
sequence-diagrams can quickly become very long, vertical folding of diagram not there?  papers mention regex-folding, but it is nowhere to be found\\

\subsection{Suggestions for improvement}\label{jiveSuggestions}
