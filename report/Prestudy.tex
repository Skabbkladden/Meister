\section{Prestudy}\label{Prestudy}
\subsection{Methods}\label{PreMethods}
There are several ways a debugger can aid the programmer beyond just showing the current state of a program.
For a fresh programmer, either in general, or at a certain project, the most useful method is probably to generate diagrams that visualize the current state, and the path of execution.
I.e. some form of object-, and/or sequence--diagram.
Such diagrams can make it easier to get an overview of a programs current state, and to understand how it works.
In order to generate the diagrams, the tools can analyze both the source-code, and an \gls{executiontrace}, depending on the type of diagrams to generate.
~\\

Execution traces can also be used to enable backwards stepping of program execution.
Stepping back in time allows the user to not only see the failure state of a program, but to go back and see what caused the problem, instead of adding a new \gls{breakpoint} and running the program again.
Each reverse step can be fairly cheap, but it may still be impractical to make large jumps in the execution history.
~\\

One can avoid the potential disadvantages of manual backstepping by using queries instead.
Queries enable the user to asks the debugger about the current and earlier states of execution in a simple way.
The debugger then does the work of finding what was asked for, instead of the user manually searching through the program states.
~\\
\subsection{Existing Tools}\label{PreTools}
There currently exists several tools that provide one or two of the methods mentioned above.
\Gls{gdb} offers a tracing environment, but due to its command-line interface %todo:cli to glossary
it is not necessarily easy to use on its own.
The \gls{traceviewer} for g-eclipse, uses a trace to generate visualizations of the program execution, and thus makes it easier to understand, but is  designed for massive parallelism, and may not be very useful for understanding smaller programs.
\Gls{whyline}\cite{ko2009}, and the \gls{tod}\cite{Pothier2007} also utilize execution traces, but use them to enable querying, instead of providing visualizations.
Additionally, Whyline exists only as a separate application, and does not integrate into any \gls{ide}.
\Gls{javavis}\cite{Oechsle2002} provides visualizations in the form of UML-diagrams, but does not provide any debugging features.
\Gls{codecanvas} uses an interesting way of visualizing an entire project,  everything from source-code to design documents and diagrams  are layered onto a large canvas, allowing easy navigation between various elements, but is restricted to Microsoft Visual Studio.
\Gls{jinsight} is a powerful tool  built by IBM, supporting both tracing and visualization.
However, it is restricted to z/OS and linux on system Z, preventing most people from using it.
~\\%stuff about jive coming up

\Gls{jive} seems to be the only tool that utilizes all three methods, as well as being freely available as a plugin for eclipse, making it easy to install and use.
During program executiion, Jive generates a \gls{contourdiagram}\cite{Jayaraman1996}, and a sequence diagram.
Combined with an execution trace, it allows the user to jump back and forth in the  execution, and have the diagrams updated accordingly.
Querying is supported through the \gls{jql}, and is accessed trough a simple graphical interface with templates for the most common queries, as well as a text-field allowing the user to write any kind of query.
~\\
Due to all the extra work being done when using jive to debug a program, the performance is not always acceptable.
For small non-interactive programs, the added waiting time may not be a problem, but larger programs may suffer from a significantly longer execution time, and even simple interactive programs can use up to a second to respond to input on a fairly powerful computer.
~\\

%temporary stuff
Jinsight\\%todo:move to glossary
	made by IBM\\
	two components: profiler and visualizer\\
	only for z/OS or Linux on system z\\
	builds a trace when application is running\\
	client connects to profiler and visualizes the trace\\
	modified JVM?\\
	120 minute trace limit\\
	very powerful\\

Javavis\\
	relies on the Java Debug Interface (JDI), and the Vivaldi Kernel (a visualization library)\\
	shows dynamic behavior of running program\\
	object diagrams+sequence diagram, UML\\
	smooth transitions\\
	not a debugger\\
	
code canvas (visual studio)\\%todo:move to glossary
	unites all project-files on a infinite zoomable surface\\
	both content and info\\
	layers of visualization - files/folders, diagrams, tests, editors, traces ++\\
	several layers visible at the same time\\
	search\\

trace viewer plugin (g-Eclipse)\\%todo:move to glossary
	g-eclipse=grid, archived project\\
	visualize and analyze communication of message-passing programs - communication graphs\\
	standalone/platform independent\\
	designed for massive parallelism - MPI and similar\\
	debugging\\
	events are marked by different colored nodes in the graphs.\\

Whyline\\%todo:move to glossary
	Interrogative debugger\\
	why did, why did not\\
	works on recorded executions\\

TOD: Trace-Oriented Debugger\\%todo:move to glossary
	omniscient debugger\\
	queries\\
	dynamic visualizations - high-level, graph of event density\\

Jive\\%todo:move to glossary
	combines all fields\\
	contour diagram - Enhanced object diagram, showing objects and their environments: fields, values, relations, inheritance, etc.\\
	sequence diagram - generated during execution, supports zooming and folding to cope with, and hide irrelevant information, but can still become quite large.\\
	stepping - state-saving enables fast backward stepping, and the current state is reflected in the diagrams.\\
	queries - enabled by state-saving. Allows filtering of irrelevant information.\\
	can be used for debugging\\




