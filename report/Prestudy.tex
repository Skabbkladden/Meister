\section{Prestudy}\label{prestudy}
\subsection{Methods}\label{PreMethods}
There are several ways a debugger can aid the programmer beyond just showing the current state of a program at a \gls{breakpoint} chosen before running.
For a fresh programmer, either in general, or at a certain project, the most useful method is probably to generate diagrams that visualize the current state, and the path of execution.
I.e. some form of object-, and/or sequence--diagram.
Such diagrams can make it easier to get an overview of a programs current state, see the contents of objects and how they relate to each other, and to understand how the various components work together.
~\\

In order to generate the diagrams, the tools can analyze both the source-code, and an \gls{executiontrace}, depending on the type of diagrams to generate.
For a general overview, a class diagram, showing how object types are composed, can be generated by simply analyzing the source code.
But in order to get a more specific view, for example of how the different components interact, an analysis, either in real-time or from an \gls{executiontrace}, of a running program is needed.
Such an analysis can be used to generate object diagrams that show how objects interact and what values they have at a given time.
One can also get a sequence diagram, showing what methods were called, and in what order.
~\\

Execution traces can also be used to enable backwards stepping of program execution.
Stepping back in time allows the user to not only see the failure state of a program, but to go back and see what caused the problem, instead of adding a new \gls{breakpoint} and running the program again.
Each reverse step can be fairly cheap, but it may still be impractical to make large jumps in the execution history.
~\\

One can avoid the potential disadvantages of manual backstepping by using queries instead.
Queries enable the user to asks the debugger about the current and earlier states of execution in a simple way.
The debugger then does the work of finding what was asked for, instead of the user manually searching through the program states.
~\\

A major downside of execution traces, is the performance penalty from doing extra work for every step in the execution.
The amount of work will vary, depending on implementation details and of course what is done with the log.
If all the tracing-process does is write to a log-file, which will be used later, one can achieve significantly smaller performance impact compared to a system that does real-time analysis of the data.
~\\

%-----------------------------------------------------------------------------------------------------------------------------
\subsection{Existing Tools}\label{PreTools}
There currently exists several tools that provide one or more of the methods mentioned above.
Some of the tools listed below does not support Java or eclipse, but provide interesting features that are worth mentioning, despite their obvious inability to be integrated into the desired teaching environment.
~\\

%not java/eclipse
\Gls{gdb} offers a tracing environment, and support for many languages, but not Java.
Due to its command-line interface (\gls{cli}), it is not necessarily easy to use on its own, and so, there are several front-end platforms that provides a graphical environment around GDB.
~\\

\Gls{codecanvas} uses an interesting way of visualizing an entire project, everything from source-code to design documents and diagrams are layered onto a large canvas, allowing easy navigation between various elements, but is restricted to Microsoft Visual Studio, and the languages it supports.
~\\

%java/eclipse
The \gls{traceviewer} \cite{Kranzlmuller} for g-eclipse, uses a trace to generate visualizations of the program execution, and thus makes it easier to understand, but is designed for massive parallelism, requires a special version of eclipse, and may not be very useful for understanding smaller programs.
~\\

\begin{sloppypar}
\Gls{whyline} \cite{ko2009}, and the \gls{tod} \cite{Pothier2007} also utilize execution traces, but use them to enable querying, instead of providing visualizations.
Additionally, Whyline exists only as a separate application, and does not integrate into any \gls{ide}.
~\\
\end{sloppypar}

The \gls{debugVisualizationPlugin} for eclipse provides an alternative to the variable view provided in eclipses debug-perspective, providing a graph that represents the variables of a program.
The user still needs to use regular techniques they would use normally in order to pause the program-execution, and be able to actually view the state of the variables.
~\\

\Gls{javavis} \cite{Oechsle2002} provides visualizations in the form of UML-diagrams, but does not provide any debugging features.
~\\

\Gls{jinsight} \cite{Pauw} is a powerful tool built by IBM, supporting both tracing and visualization.
However, it is restricted to z/OS and linux on system Z, preventing most people from using it.
~\\

%stuff about jive coming up, sloppypar to fix cite going over margins
\begin{sloppypar}
\Gls{jive} seems to be the only tool that utilizes all three methods, as well as being freely available as a plugin for eclipse, making it easy to install and use.
During program execution, Jive generates a \gls{contourdiagram} \cite{Jayaraman1996}, and a sequence diagram.
Combined with an execution trace, it allows the user to jump back and forth in the execution, and have the diagrams updated accordingly.
Querying is supported through the \gls{jql}, and is accessed trough a simple graphical interface with templates for the most common queries, as well as a text-field allowing the user to write any kind of query.
~\\
\end{sloppypar}

Due to all the extra work being done when using jive to debug a program, the performance is not always acceptable.
For small non-interactive programs, the added waiting time may not be a problem, but larger programs may suffer from a significantly longer execution time, and even simple interactive programs can use up to a second to respond to input on a fairly powerful computer.
~\\





